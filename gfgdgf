--!strict
-- LocalScript (StarterGui) — полностью client-side. Никаких RemoteEvents/RemoteFunctions.

--========================================================
--                     ИМПОРТЫ/ССЫЛКИ
--========================================================
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera

--========================================================
--               КОНСТАНТЫ / НАСТРОЙКИ
--========================================================
local PLATFORM_TAG = "PlacementPlatform"     -- основной способ пометить платформы
local PLATFORM_NAME = "PlacementPlatform"    -- альтернативно — по имени
local PREVIEW_OFFSET = 0.1                   -- на сколько поднимать предпросмотр над поверхностью
local UI_SIZE = UDim2.fromOffset(280, 120)
local UI_PADDING = 10
local TITLE_HEIGHT = 28
local CORNER_RADIUS = 10
local BUTTON_HEIGHT = 32
local BUTTON_PAD = 8
local TOAST_TIME = 2.0
local RAY_DISTANCE = 1000
local PLACE_ON_GRID = false                  -- при желании можно включить
local GRID_SIZE = 1

--========================================================
--                   ЛОКАЛЬНОЕ СОСТОЯНИЕ
--========================================================
local managedPlacedStack: {Model} = {}       -- стек установленных клонов (LIFO)
local previewModel: Model? = nil             -- текущий предпросмотр
local previewConnHeartbeat: RBXScriptConnection? = nil
local highlightBox: SelectionBox? = nil      -- подсветка платформы
local virtualHotbar: {Instance} = {}         -- простая виртуальная запись предметов (client-only)
local dragState = { dragging = false, offset = Vector2.zero }

--========================================================
--                   ВСПОМОГАТЕЛЬНЫЕ УТИЛИТЫ
--========================================================
local function showToast(msg: string)
    -- Ненавязчивая подсказка (сверху экрана)
    StarterGui:SetCore("SendNotification", {
        Title = "Hint",
        Text = msg,
        Duration = TOAST_TIME
    })
end

local function isPlatform(inst: Instance): boolean
    if not inst then return false end
    if CollectionService:HasTag(inst, PLATFORM_TAG) then return true end
    local ok, _ = pcall(function() return inst.Name end)
    if ok and inst.Name == PLATFORM_NAME then return true end
    -- Если навели на вложенный Part внутри модели-платформы
    local parent = inst.Parent
    if parent and (CollectionService:HasTag(parent, PLATFORM_TAG) or parent.Name == PLATFORM_NAME) then
        return true
    end
    return false
end

local function getPlatformRoot(inst: Instance): BasePart?
    if not inst then return nil end
    if inst:IsA("BasePart") and isPlatform(inst) then
        return inst
    end
    if inst.Parent and inst.Parent:IsA("Model") and isPlatform(inst.Parent) then
        -- найдём центральную деталь модели-платформы
        local primary = (inst.Parent :: Model).PrimaryPart
        if primary and primary:IsA("BasePart") then return primary end
        -- fallback — любой Part
        for _, d in ipairs(inst.Parent:GetDescendants()) do
            if d:IsA("BasePart") then return d end
        end
    end
    if inst.Parent and inst.Parent:IsA("BasePart") and isPlatform(inst.Parent) then
        return inst.Parent
    end
    return nil
end

local function snapToGrid(v: Vector3): Vector3
    if not PLACE_ON_GRID then return v end
    local function s(x) return math.floor((x + GRID_SIZE/2)/GRID_SIZE)*GRID_SIZE end
    return Vector3.new(s(v.X), s(v.Y), s(v.Z))
end

local function getEquippedTool(): Instance?
    -- Ищем активный Tool: либо в Character, либо у Mouse.Target? — стандартно берём из Character
    local char = LocalPlayer.Character
    if not char then return nil end
    for _, inst in ipairs(char:GetChildren()) do
        if inst:IsA("Tool") then
            return inst
        end
    end
    return nil
end

local function ensureModelFromTool(toolOrModel: Instance): Model?
    -- Возвращаем Model для унифицированной работы
    if toolOrModel:IsA("Model") then
        return toolOrModel:Clone()
    end
    if toolOrModel:IsA("Tool") then
        -- Клонируем Tool и собираем Model из его содержимого
        local toolClone = toolOrModel:Clone()
        -- Если у Tool есть Handle — уже достаточно для визуала. Но соберём всё как модель:
        local model = Instance.new("Model")
        model.Name = toolOrModel.Name .. "_Clone"
        for _, ch in ipairs(toolClone:GetChildren()) do
            ch.Parent = model
        end
        -- Попытаемся назначить PrimaryPart
        local primary: BasePart? = nil
        local handle = model:FindFirstChild("Handle", true)
        if handle and handle:IsA("BasePart") then
            primary = handle
        else
            for _, d in ipairs(model:GetDescendants()) do
                if d:IsA("BasePart") then primary = d; break end
            end
        end
        if primary then
            (model :: Model).PrimaryPart = primary
        end
        return model
    end
    return nil
end

local function setModelCollision(model: Model, canCollide: boolean)
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then
            d.CanCollide = canCollide
        end
    end
end

local function setModelAnchored(model: Model, anchored: boolean)
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then
            d.Anchored = anchored
            d.AssemblyLinearVelocity = Vector3.zero
            d.AssemblyAngularVelocity = Vector3.zero
        end
    end
end

local function tagManaged(model: Model)
    model:SetAttribute("ClientManagedClone", true)
end

local function isManaged(inst: Instance?): boolean
    if not inst then return false end
    if inst:IsA("Model") then
        return inst:GetAttribute("ClientManagedClone") == true
    end
    local m = inst:FindFirstAncestorOfClass("Model")
    if m then
        return m:GetAttribute("ClientManagedClone") == true
    end
    return false
end

local function modelBounds(model: Model): (CFrame, Vector3)
    local cf, size = model:GetBoundingBox()
    return cf, size
end

local function centerOnPlatform(model: Model, platformPart: BasePart)
    -- Ставим центр модели в центр платформы. Выравниваем ориентацию по платформе.
    local _, size = modelBounds(model)
    local halfHeight = size.Y * 0.5
    local targetCF = platformPart.CFrame
    local upOffset = Vector3.new(0, (platformPart.Size.Y * 0.5) + halfHeight, 0)
    local finalPos = targetCF.Position + upOffset
    finalPos = snapToGrid(finalPos)
    -- Поворот как у платформы
    local finalCF = CFrame.new(finalPos) * CFrame.fromMatrix(Vector3.new(), targetCF.XVector, targetCF.YVector, targetCF.ZVector)
    model:PivotTo(finalCF)
end

local function gentlyPop(model: Model)
    -- Лёгкая анимация "щёлк" при установке
    local parts: {BasePart} = {}
    for _, d in ipairs(model:GetDescendants()) do
        if d:IsA("BasePart") then table.insert(parts, d) end
    end
    if #parts == 0 then return end
    -- Подняли на чуть-чуть…
    for _, p in ipairs(parts) do
        p.Position += Vector3.new(0, 0.05, 0)
    end
    task.delay(0.02, function()
        -- и вернули обратно
        for _, p in ipairs(parts) do
            p.Position -= Vector3.new(0, 0.05, 0)
        end
    end)
end

--========================================================
--                         UI
--========================================================
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ClientClonerUI"
ScreenGui.IgnoreGuiInset = true
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = PlayerGui

-- Основная панель
local Frame = Instance.new("Frame")
Frame.Size = UI_SIZE
Frame.AnchorPoint = Vector2.new(0.5, 0.5)
Frame.Position = UDim2.fromScale(0.5, 0.5)
Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
Frame.BorderSizePixel = 0
Frame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
UICorner.Parent = Frame

local UIStroke = Instance.new("UIStroke")
UIStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
UIStroke.Thickness = 1
UIStroke.Color = Color3.fromRGB(70, 70, 80)
UIStroke.Parent = Frame

-- Тайтлбар
local TitleBar = Instance.new("Frame")
TitleBar.Size = UDim2.new(1, 0, 0, TITLE_HEIGHT)
TitleBar.BackgroundTransparency = 0.1
TitleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = Frame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, CORNER_RADIUS)
TitleCorner.Parent = TitleBar

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Size = UDim2.new(1, -UI_PADDING*2, 1, 0)
TitleLabel.Position = UDim2.fromOffset(UI_PADDING, 0)
TitleLabel.Text = "Client Clone & Place"
TitleLabel.Font = Enum.Font.GothamSemibold
TitleLabel.TextSize = 16
TitleLabel.TextColor3 = Color3.fromRGB(230, 230, 240)
TitleLabel.BackgroundTransparency = 1
TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
TitleLabel.Parent = TitleBar

-- Контейнер для контента
local Content = Instance.new("Frame")
Content.Size = UDim2.new(1, -UI_PADDING*2, 1, -(TITLE_HEIGHT + UI_PADDING*2))
Content.Position = UDim2.fromOffset(UI_PADDING, TITLE_HEIGHT + UI_PADDING)
Content.BackgroundTransparency = 1
Content.Parent = Frame

local UIListLayout = Instance.new("UIListLayout")
UIListLayout.FillDirection = Enum.FillDirection.Vertical
UIListLayout.Padding = UDim.new(0, BUTTON_PAD)
UIListLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
UIListLayout.VerticalAlignment = Enum.VerticalAlignment.Top
UIListLayout.Parent = Content

local function makeButton(txt: string): TextButton
    local b = Instance.new("TextButton")
    b.Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT)
    b.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
    b.AutoButtonColor = true
    b.Text = txt
    b.Font = Enum.Font.Gotham
    b.TextSize = 16
    b.TextColor3 = Color3.fromRGB(245, 245, 255)
    b.BorderSizePixel = 0

    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, math.floor(CORNER_RADIUS*0.8))
    c.Parent = b

    local s = Instance.new("UIStroke")
    s.Thickness = 1
    s.Color = Color3.fromRGB(80, 80, 100)
    s.Parent = b

    b.MouseEnter:Connect(function()
        TweenService:Create(b, TweenInfo.new(0.08), {BackgroundColor3 = Color3.fromRGB(65, 65, 85)}):Play()
    end)
    b.MouseLeave:Connect(function()
        TweenService:Create(b, TweenInfo.new(0.12), {BackgroundColor3 = Color3.fromRGB(50, 50, 65)}):Play()
    end)
    b.MouseButton1Down:Connect(function()
        TweenService:Create(b, TweenInfo.new(0.05), {BackgroundColor3 = Color3.fromRGB(80, 80, 110)}):Play()
    end)
    b.MouseButton1Up:Connect(function()
        TweenService:Create(b, TweenInfo.new(0.08), {BackgroundColor3 = Color3.fromRGB(65, 65, 85)}):Play()
    end)

    return b
end

local DuplicateBtn = makeButton("Duplicate")
DuplicateBtn.Parent = Content

local DeleteBtn = makeButton("Delete")
DeleteBtn.Parent = Content

-- Перетаскивание окна
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragState.dragging = true
        dragState.offset = Vector2.new(Mouse.X - Frame.AbsolutePosition.X, Mouse.Y - Frame.AbsolutePosition.Y)
    end
end)
TitleBar.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragState.dragging = false
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragState.dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local newPos = Vector2.new(Mouse.X - dragState.offset.X, Mouse.Y - dragState.offset.Y)
        Frame.Position = UDim2.fromOffset(newPos.X, newPos.Y)
    end
end)

--========================================================
--                ПОДСВЕТКА ПЛАТФОРМЫ (SelectionBox)
--========================================================
highlightBox = Instance.new("SelectionBox")
highlightBox.Name = "PlatformHighlight"
highlightBox.LineThickness = 0.05
highlightBox.Color3 = Color3.fromRGB(120, 180, 255)
highlightBox.Transparency = 0.2
highlightBox.Visible = false
highlightBox.Parent = ScreenGui

local function setHighlight(part: BasePart?)
    if part then
        highlightBox.Adornee = part
        highlightBox.Visible = true
    else
        highlightBox.Adornee = nil
        highlightBox.Visible = false
    end
end

--========================================================
--                   ПРЕДПРОСМОТР / СЛЕЖЕНИЕ
--========================================================
local function destroyPreview()
    if previewConnHeartbeat then
        previewConnHeartbeat:Disconnect()
        previewConnHeartbeat = nil
    end
    if previewModel and previewModel.Parent then
        previewModel:Destroy()
    end
    previewModel = nil
    setHighlight(nil)
end

local function startPreview(model: Model)
    destroyPreview()
    previewModel = model
    model.Parent = workspace
    setModelAnchored(model, false)  -- как по ТЗ: перед установкой Anchored=false
    setModelCollision(model, false) -- в предпросмотре отключим коллизии, чтобы не мешал
    tagManaged(model)

    -- Подкачка за курсором
    previewConnHeartbeat = RunService.Heartbeat:Connect(function()
        if not previewModel then return end

        -- Луч из камеры к курсору
        local unitRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
        local origin = unitRay.Origin
        local dir = unitRay.Direction * RAY_DISTANCE

        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.FilterDescendantsInstances = {previewModel} -- игнорируем сам предпросмотр

        local result = workspace:Raycast(origin, dir, params)
        local targetCF: CFrame
        local hoverPlatform: BasePart? = nil

        if result then
            local hitPos = result.Position + result.Normal * PREVIEW_OFFSET
            targetCF = CFrame.new(snapToGrid(hitPos))
            -- Мягко ориентировать по поверхности не будем — предпросмотр просто следует за мышью
            if isPlatform(result.Instance) then
                hoverPlatform = getPlatformRoot(result.Instance)
            end
        else
            -- Если ничего не попали, подвинем в направлении взгляда
            targetCF = CFrame.new(origin + dir)
        end

        previewModel:PivotTo(targetCF)

        -- Подсветка платформы при зажатой E
        if UserInputService:IsKeyDown(Enum.KeyCode.E) and hoverPlatform then
            setHighlight(hoverPlatform)
        else
            setHighlight(nil)
        end
    end)
end

--========================================================
--                   УСТАНОВКА ПО ЗАЖАТИЮ E
--========================================================
local function placePreviewIfPossible()
    if not previewModel then
        showToast("Нечего ставить. Сначала Duplicate.")
        return
    end

    -- Луч на платформу
    local unitRay = Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
    local origin = unitRay.Origin
    local dir = unitRay.Direction * RAY_DISTANCE

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {previewModel}

    local result = workspace:Raycast(origin, dir, params)
    if not result or not result.Instance then
        showToast("Нет платформы под курсором.")
        return
    end

    if not isPlatform(result.Instance) then
        showToast("Наведите на платформу, помеченную как PlacementPlatform.")
        return
    end

    local platformRoot = getPlatformRoot(result.Instance)
    if not platformRoot then
        showToast("Не удалось определить центр платформы.")
        return
    end

    -- Центрируем и закрепляем
    centerOnPlatform(previewModel, platformRoot)
    setModelCollision(previewModel, true)
    setModelAnchored(previewModel, true)
    gentlyPop(previewModel)

    -- Добавляем в стек управляемых
    table.insert(managedPlacedStack, previewModel)
    previewModel = nil
    if previewConnHeartbeat then
        previewConnHeartbeat:Disconnect()
        previewConnHeartbeat = nil
    end
    setHighlight(nil)
    showToast("Объект установлен.")
end

-- Слежка за клавишей E (зажатие = удерживаем для подсветки, отпускание не нужно)
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.E then
        -- В момент нажатия попробуем сразу поставить (зажатие допустимо; повторные Heartbeat-кадры всё равно подсвечивают)
        placePreviewIfPossible()
    end
end)

--========================================================
--                       ДУБЛИРОВАНИЕ
--========================================================
local function duplicateEquipped()
    local toolOrModel = getEquippedTool()
    if not toolOrModel then
        showToast("Нет экипированного предмета.")
        return
    end

    local cloneModel = ensureModelFromTool(toolOrModel)
    if not cloneModel then
        showToast("Не удалось клонировать предмет.")
        return
    end

    -- Копирование “ключевых свойств” визуала:
    -- Имя, материал/текстуры и т.п. копируются самим Clone().
    -- Для наглядности пройдёмся по текстовым объектам/SurfaceGui/Decal и постараемся сохранить текст/цвет.
    for _, d in ipairs(cloneModel:GetDescendants()) do
        -- Примеры: TextLabel/SurfaceGui/TextBillboard и т.д.
        if d:IsA("TextLabel") or d:IsA("TextButton") then
            -- оставляем как есть; можно было бы прокинуть цвет/шрифт, но Clone уже сделал копию
        elseif d:IsA("Decal") or d:IsA("Texture") then
            -- Clone сохраняет TextureId/Color3
        end
    end

    -- Добавляем в виртуальный хотбар (client-only запись)
    table.insert(virtualHotbar, cloneModel)

    -- Включаем предпросмотр
    startPreview(cloneModel)
    showToast("Клон создан. Зажмите E, чтобы поставить.")
end

--========================================================
--                         УДАЛЕНИЕ
--========================================================
local function deleteTargetOrLast()
    -- Если есть предпросмотр — удаляем его
    if previewModel then
        destroyPreview()
        showToast("Предпросмотр отменён.")
        return
    end

    -- Попробуем удалить клон под курсором (если он клиентский/наш)
    local target = Mouse.Target
    if target and isManaged(target) then
        local model = target:FindFirstAncestorOfClass("Model")
        if model and model:IsDescendantOf(workspace) then
            model:Destroy()
            -- Также убираем из стека, если он там есть
            for i = #managedPlacedStack, 1, -1 do
                if managedPlacedStack[i] == model then
                    table.remove(managedPlacedStack, i)
                    break
                end
            end
            showToast("Удалено под курсором.")
            return
        end
    end

    -- Иначе — удаляем последний установленный (LIFO)
    if #managedPlacedStack == 0 then
        showToast("Нечего удалить.")
        return
    end
    local last = managedPlacedStack[#managedPlacedStack]
    if last and last:IsDescendantOf(workspace) then
        last:Destroy()
    end
    table.remove(managedPlacedStack, #managedPlacedStack)
    showToast("Удалён последний установленный объект.")
end

--========================================================
--                     ПРИВЯЗКА КНОПОК UI
--========================================================
DuplicateBtn.MouseButton1Click:Connect(function()
    duplicateEquipped()
end)

DeleteBtn.MouseButton1Click:Connect(function()
    deleteTargetOrLast()
end)

--========================================================
--                ДРУЖЕСТВЕННЫЕ ПОДСКАЗКИ / UX
--========================================================
showToast("Готово. Duplicate → наведите на платформу → зажмите E. Delete — убрать.")
